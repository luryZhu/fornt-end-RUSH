> 设想一个场景，页面中有多个相同组件，加载时，组件内部会发起相同的请求，我们希望避免同一时间重复请求的问题。

目标：实现一个函数enhancedHttp()，增加http请求去重的能力。

当新发起一个请求时，判断是否存在进行中的相同请求（请求参数一致即相同）：

- 如果存在，复用该进行中的请求，不发起新请求。
- 如果不存在,发起新请求。

附加题: 基于上述目标，如果一次会话内，发起的请求是被请求过的，直接使用上次相同请求的返回结果，不真的发起请求。



# 思路

## axios请求

https://juejin.cn/post/7001307104917061645

拦截器文档：https://www.axios-http.cn/docs/interceptors

``` js
// axios.js
const pending = new Map()
/**
 * 添加请求
 * @param {Object} config
 **/
const addPending = (config) => {
  const url = [
    config.method,
    config.url,
    qs.stringify(config.data)
  ].join('&')
  if (pending.has(url)) { // 如果 pending 中存在当前请求则取消后面的请求
    config.cancelToken = new axios.CancelToken(cancel => cancel(`重复的请求被主动拦截: ${url}`))
  } else { // 如果 pending 中不存在当前请求，则添加进去
    config.cancelToken = config.cancelToken || new axios.CancelToken(cancel => {
      pending.set(url, {retult:null, cancel})
    })
  }
}
/**
 * 移除请求
 * @param {Object} config
 */
const removePending = (config) => {
  const url = [
    config.method,
    config.url.replace(config.baseURL, ''), // 响应url会添加域名，需要去掉与请求URL保持一致
    qs.stringify(JSON.parse(config.data)) // 需要与request的参数结构保持一致，request中是对象，response中是字符串
  ].join('&')
  if (pending.has(url)) { // 如果在 pending 中存在当前请求标识，取消当前请求，并且移除
    pending.delete(url)
  }
}

/* axios全局请求参数设置，请求拦截器 */
axios.interceptors.request.use(
  config => {
    addPending(config) // 将当前请求添加到 pending 中
    return config
  },
  error => {
    return Promise.reject(error)
  }
)
// 响应拦截器即异常处理
axios.interceptors.response.use(
  response => {
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    removePending(response.config) // 在请求结束后，移除本次请求
    return response
  },
  err => {
    if (err && err.config) {
      removePending(err.config) // 在请求结束后，移除本次请求
    }
    return Promise.resolve(err.response)
  }
)
```



## AJAX请求

``` js
const HttpRequests=new Map()

function sendAJAX(){
  return new Promise((resolve,reject)=>{
    let xhr=new XMLHttpRequest()
    xhr.open(...arguments)
    xhr.send()
    console.log("sendRequest");
    xhr.onreadystatechange=function(){
      if (xhr.readyState===4){
        if (xhr.status>=200 &&xhr.status<300){
          resolve(xhr.response)
        } else {
          reject(xhr.statusText)
        }
      }
    }
  })
}

async function enhancedHttp(){
  let argString=JSON.stringify(arguments)
  // 判断，已有请求
  if (HttpRequests.has(argString)) {
      console.log("已有请求，请等待结果");
    return HttpRequests.get(argString)
  }
  // 没有请求
  let result=sendAJAX(...arguments)
  HttpRequests.set(argString, result)
  return result

}
```

